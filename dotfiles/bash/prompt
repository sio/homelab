#
# Build a pretty prompt for bash
#
# To invoke add `source prompt` to your ~/.bashrc
#


_color() {
    # Build colored prompt components with proper escape sequences
    #
    # Usage:
    #     color code text
    # code
    #     Color code, e.g. "1;34m"
    # text
    #     String to be colored
    #
    # ASCII colors (foreground: 30-37, background: 40-47)
    #   0: black,   1: red,       2: green,    3: yellow,
    #   4: blue,    5: magenta,   6: cyan,     7: white
    #
    # Note: \[ and \] are important for shell to properly calculate
    # length of the prompt. Otherwise there might be some garbage
    # left after some interactive operations, e.g. reverse-history-search.

    local start='\[\033['
    local end='\]'
    local revert='\[\033[0m\]'

    local color="$1"
    local value="$2"
    if [ ! -z "$value" ]
    then
        echo -n "$start$color$end$value$revert"
    fi
}


_prompt_usercolor() {
    # Return a color code for each user
    #
    # Generated from username and hostname, always red for root

    local user=$(id -u -n)
    if [ "x$user" = "xroot" ]
    then
        local color=1
    else
        local host=$(hostname)
        local color=$(_prompt_colorhash "$user@$host")
    fi
    echo -n $color
}


_prompt_colorhash() {
    # Reduce a string to a color code. Black, white and red
    # are considered reserved and are never returned.
    #
    # Usage:
    #   _prompt_colorhash text

    local number=5  # available colors: green, yellow, blue, magenta, cyan
    local hash=$(echo "$*" | sum -s | cut -d\  -f1)
    echo -n $(($hash % $number + 2))
}


_prompt_git_branch() {
    local branch=$(git branch 2>/dev/null)
    [ ! -z "$branch" ] && branch=$(echo "$branch"|grep -E '^\* '|cut -d\  -f2-| xargs)
    [ ! -z "$branch" ] && echo -n " ($branch)"
}


_prompt_exit_code() {
    local exit="$?"
    if [ ! "$exit" -eq 0 ]
    then
        echo -ne "Exit code: $exit\n\r"
    fi
}


_prompt_nested_level() {
    if [ "$_NESTED_LEVEL" -gt 1 ]
    then
        echo -ne " ($_NESTED_LEVEL)"
    fi
}


_prompt_jobs() {
    if [[ -n "$(jobs -p)" ]]
    then
        printf " (&)"
    fi
}


_prompt() {
    local usrclr=$(_prompt_usercolor)

    local newlines='\n\n'
    local who=$(_color "1;3${usrclr}m" '[\u@\h]')
    local trailing_slash='`[ ${#PWD} -gt 1 ] && echo -n /`'
    local path=$(_color "32m" '$PWD'"$trailing_slash")
    local bang=$(_color "1;3${usrclr}m" '\$ ')
    local gitbranch=$(_color "33m" '`_prompt_git_branch`')
    local exitcode=$(_color "31m" '`_prompt_exit_code`')
    local level=$(_color '34m' "$(_prompt_nested_level)")
    local jobs=$(_color "35m" '`_prompt_jobs`')
    echo -n "$exitcode$newlines$who $path$gitbranch$level$jobs\n$bang"
}


_prompt_calculate_nested_level() {
    local parent="$(ps -p $PPID)"
    parent="${parent##* }"  # select last field of output table
    parent="${parent##*/}"  # select basename of the executable
    if [[ "$parent" =~ .*sh \
       || "$parent" == "make" \
       || "$PPID" == '1' ]]
    then
        # Increment only for sessions started by another shell,
        # PPID=1 is a special case for detached processes fathered by Make
        _NESTED_LEVEL=$(("$_NESTED_LEVEL"+1))
    else
        _NESTED_LEVEL=1
    fi
    export _NESTED_LEVEL
}
_prompt_calculate_nested_level


PS1=$(_prompt)
